<?xml version="1.0" encoding="utf-8"?>
<testsuite package="org.spotbugs" time="0" tests="14" errors="18" name="findbugs">
<testcase time="0" name="model/domain/Item.java" classname="FindBugs Issues">
<failure message="issues" ><![CDATA[lines: 20-256 
new model.domain.Item(String, String, int, int, Boolean, int, String, 
  String, String) uses the same code for two branches 
Method uses the same code for two branches 
This method uses the same code to implement two branches of a conditional 
  branch. Check to ensure that this isn't a coding mistake.
----------------
lines: 20-256 
Call to equals(null) in new model.domain.Item(String, String, int, int, 
  Boolean, int, String, String, String) 
Call to equals(null) 
This method calls equals(Object), passing a null value as the argument. 
  According to the contract of the equals() method, this call should always 
  return false.
----------------
lines: 20-256 
Unwritten public or protected field: itemClass 
Unwritten public or protected field 
No writes were seen to this public/protected field. All reads of it will 
  return the default value. Check for errors (should it have been 
  initialized?), or remove it if it is useless.
----------------
]]></failure>
</testcase><testcase time="0" name="model/domain/MemberId.java" classname="FindBugs Issues">
</testcase><testcase time="0" name="view/ConsoleUi.java" classname="FindBugs Issues">
<failure message="issues" ><![CDATA[lines: 21-426 
byeBye() invokes System.exit(...), which shuts down the entire virtual 
  machine 
Method invokes System.exit(...) 
Invoking System.exit shuts down the entire Java virtual machine. This 
  should only been done when it is appropriate. Such calls make it hard or 
  impossible for your code to be invoked by other code. Consider throwing a 
  RuntimeException instead.
----------------
]]></failure>
</testcase><testcase time="0" name="controller/Controller.java" classname="FindBugs Issues">
</testcase><testcase time="0" name="controller/MemberController.java" classname="FindBugs Issues">
<failure message="issues" ><![CDATA[lines: 17-300 
new controller.MemberController(ConsoleUi, Registry) may expose internal 
  representation by storing an externally mutable object into 
  MemberController.console 
May expose internal representation by incorporating reference to mutable 
  object 
This code stores a reference to an externally mutable object into the 
  internal representation of the object. If instances are accessed by 
  untrusted code, and unchecked changes to the mutable object would 
  compromise security or other important properties, you will need to do 
  something different. Storing a copy of the object is better approach in 
  many situations.
----------------
lines: 17-300 
new controller.MemberController(ConsoleUi, Registry) may expose internal 
  representation by storing an externally mutable object into 
  MemberController.registry 
May expose internal representation by incorporating reference to mutable 
  object 
This code stores a reference to an externally mutable object into the 
  internal representation of the object. If instances are accessed by 
  untrusted code, and unchecked changes to the mutable object would 
  compromise security or other important properties, you will need to do 
  something different. Storing a copy of the object is better approach in 
  many situations.
----------------
lines: 17-300 
Nullcheck of input at line 167 of value previously dereferenced in 
  isNull(String) 
Nullcheck of value previously dereferenced 
A value is checked here to see whether it is null, but this value cannot be 
  null because it was previously dereferenced and if it were null a null 
  pointer exception would have occurred at the earlier dereference. 
  Essentially, this code and the previous dereference disagree as to 
  whether this value is allowed to be null. Either the check is redundant 
  or the previous dereference is erroneous.
----------------
]]></failure>
</testcase><testcase time="0" name="model/domain/Registry.java" classname="FindBugs Issues">
<failure message="issues" ><![CDATA[lines: 10-178 
Dead store to i in createContract(Member, Member, int, int) 
Dead store to local variable 
This instruction assigns a value to a local variable, but the value is not 
  read or used in any subsequent instruction. Often, this indicates an 
  error, because the value computed is never used. 
 
Note that Sun's javac compiler often generates dead stores for final local 
  variables. Because SpotBugs is a bytecode-based tool, there is no easy 
  way to eliminate these false positives.
----------------
lines: 10-178 
getMembers() may expose internal representation by returning 
  Registry.members 
May expose internal representation by returning reference to mutable object 
Returning a reference to a mutable object value stored in one of the 
  object's fields exposes the internal representation of the object. If 
  instances are accessed by untrusted code, and unchecked changes to the 
  mutable object would compromise security or other important properties, 
  you will need to do something different. Returning a new copy of the 
  object is better approach in many situations.
----------------
]]></failure>
</testcase><testcase time="0" name="controller/App.java" classname="FindBugs Issues">
</testcase><testcase time="0" name="model/domain/Contract.java" classname="FindBugs Issues">
<failure message="issues" ><![CDATA[lines: 18-30 
getLentTo() may expose internal representation by returning Contract.lentTo 
May expose internal representation by returning reference to mutable object 
Returning a reference to a mutable object value stored in one of the 
  object's fields exposes the internal representation of the object. If 
  instances are accessed by untrusted code, and unchecked changes to the 
  mutable object would compromise security or other important properties, 
  you will need to do something different. Returning a new copy of the 
  object is better approach in many situations.
----------------
lines: 18-30 
getOwner() may expose internal representation by returning Contract.owner 
May expose internal representation by returning reference to mutable object 
Returning a reference to a mutable object value stored in one of the 
  object's fields exposes the internal representation of the object. If 
  instances are accessed by untrusted code, and unchecked changes to the 
  mutable object would compromise security or other important properties, 
  you will need to do something different. Returning a new copy of the 
  object is better approach in many situations.
----------------
lines: 18-30 
new model.domain.Contract(Member, Member, int, int) may expose internal 
  representation by storing an externally mutable object into 
  Contract.lentTo 
May expose internal representation by incorporating reference to mutable 
  object 
This code stores a reference to an externally mutable object into the 
  internal representation of the object. If instances are accessed by 
  untrusted code, and unchecked changes to the mutable object would 
  compromise security or other important properties, you will need to do 
  something different. Storing a copy of the object is better approach in 
  many situations.
----------------
lines: 18-30 
new model.domain.Contract(Member, Member, int, int) may expose internal 
  representation by storing an externally mutable object into 
  Contract.owner 
May expose internal representation by incorporating reference to mutable 
  object 
This code stores a reference to an externally mutable object into the 
  internal representation of the object. If instances are accessed by 
  untrusted code, and unchecked changes to the mutable object would 
  compromise security or other important properties, you will need to do 
  something different. Storing a copy of the object is better approach in 
  many situations.
----------------
lines: 18-30 
Unread field: contractPeriod 
Unread field 
This field is never read. Consider removing it from the class.
----------------
lines: 18-30 
Unread field: item 
Unread field 
This field is never read. Consider removing it from the class.
----------------
]]></failure>
</testcase><testcase time="0" name="model/domain/Member.java" classname="FindBugs Issues">
<failure message="issues" ><![CDATA[lines: 17-301 
Dead store to item in updateItems() 
Dead store to local variable 
This instruction assigns a value to a local variable, but the value is not 
  read or used in any subsequent instruction. Often, this indicates an 
  error, because the value computed is never used. 
 
Note that Sun's javac compiler often generates dead stores for final local 
  variables. Because SpotBugs is a bytecode-based tool, there is no easy 
  way to eliminate these false positives.
----------------
lines: 17-301 
getItemsOwned() may expose internal representation by returning 
  Member.itemsOwned 
May expose internal representation by returning reference to mutable object 
Returning a reference to a mutable object value stored in one of the 
  object's fields exposes the internal representation of the object. If 
  instances are accessed by untrusted code, and unchecked changes to the 
  mutable object would compromise security or other important properties, 
  you will need to do something different. Returning a new copy of the 
  object is better approach in many situations.
----------------
lines: 17-301 
Unused field: costTotal 
Unused field 
This field is never used. Consider removing it from the class.
----------------
]]></failure>
</testcase><testcase time="0" name="model/domain/Time.java" classname="FindBugs Issues">
</testcase><testcase time="0" name="model/persistence/Imapper.java" classname="FindBugs Issues">
</testcase><testcase time="0" name="model/TimeAdvancedObserver.java" classname="FindBugs Issues">
</testcase><testcase time="0" name="model/persistence/SqlMapper.java" classname="FindBugs Issues">
</testcase><testcase time="0" name="model/persistence/Persistence.java" classname="FindBugs Issues">
</testcase></testsuite>